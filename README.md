# rabbitmq-MyInfo
# RabbitMq的基础使用方法

## 简介

包括读rabbitMq队列，交换机声明定义，以及队列的**兜底**，队列的**发布订阅模式**进行简单的定义以及配置：

包括当队列发生异常时，转发到死信队列

包括当队列消息转发超时时，转发到死信队列

并且,该配置包含了持久化，手动确认防止消息丢失，但是因为是配置问题，所以并没有涉及到解决**消息幂等**的策略,
所以我会在下方提供一个解决消息幂等的方案，**仅供参考**！


## 架构图

![架构图实例](https://github.com/nacey5/rabbitmq-MyInfo/blob/master/mq_Default1.png)
## 注意！！！

在此项目中，基础配置采用的是死信队列进行兜底和手动应答，这样可以最大程度的防止消息因为服务器宕机等其他因素导致消息丢失，**但是**，这并不代表了完全安全，一样有消息丢失的**风险**！！
## 消息幂等问题

消息幂等问题就是当一条消息可能在多线程的环境下因为不同的原因导致**消息被消费者消费多次**或者生**产者多次产生**导致出现消息幂等问题，那么这样对于一些**涉及金钱的业务**来讲非常致命的。

### 解决方式一：唯一ID+指纹码

我们可以采用**UUID的方式+业务相关的信息+时间戳+登陆token**的固定位数来进行对消息的唯一确定，[可以用多种方法保证消息唯一性]，利用查询语句判断是否重复的问题，这种方式用来解决**单机**的消息比较简单，但是，我个人并不是很推荐这个方法，因为在高并发时需要不断地对服务器进行查询，可能会导致**数据库服务器压力过大**！！

### 解决方式二：Redis原子性

如果您只是听说过redis或者不了解redis，我强烈推荐您可以去深入了解下redis，您会发现很多地惊喜。对于消息幂等性来讲，如果了解redis的特性的话，那么我们很容易知道redis天生具有的一个命令

**setnx**，天然具有幂等性，从而实现不重复消费。


